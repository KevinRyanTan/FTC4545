#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTGYRO,         sensorAnalogInactive)
#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorNull,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorFL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorLeftPulley, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorBL,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorManipulator, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorRightPulley, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S4_C1_1,    servoLeftBridge,      tServoStandard)
#pragma config(Servo,  srvo_S4_C1_2,    servoRightBridge,     tServoStandard)
#pragma config(Servo,  srvo_S4_C1_3,    servoRearGrabberR,    tServoStandard)
#pragma config(Servo,  srvo_S4_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_5,    servoRearGrabberL,    tServoStandard)
#pragma config(Servo,  srvo_S4_C1_6,    servo1,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Establishing global variables
float x1 = 0;
float y1 = 0;
float x2 = 0;
float joy2y1 = 0;
float joy2y2 = 0;
float num = 0.00;
float FL = 0.00;
float BL = 0.00;
float FR = 0.00;
float BR = 0.00;
int y2 = 0;

#include "JoystickDriver.c"
#include "normalize.h"

void initializeRobot(){
	return;
} // end of initialization

task moveLift()
{
	int diff = 0;
	servo[servoRightBridge] = 0;
	servo[servoLeftBridge] = 240;
	while(true)
	{
		if(joy2Btn(6))
			diff += 1;
		else if(joy2Btn(8))
			diff -= 1;
		if(diff < 0)
			diff = 0;
		else if(diff > 140)
			diff = 140;
		servo[servoRightBridge] = diff;
		servo[servoLeftBridge] = 240 - diff;
		wait1Msec(5);
		nxtDisplayCenteredBigTextLine(2,"%d",diff);
	}
}

task moveGrabber()
{
	bool grabChoice = false; //True for
	if(grabChoice)
	{
		int dif = 127;
		while(true)
		{
			if(joy1Btn(6))
				dif+=10;
			if(joy1Btn(8))
				dif-=10;
			if(dif < 0)
				dif = 0;
			if(dif > 270)
				dif = 270;
			servo[servoRearGrabberR] = dif - 15;
			servo[servoRearGrabberL] = 255 - dif;
			nxtDisplayCenteredBigTextLine(2,"%d",dif);
			wait1Msec(50);
		}
	}
	else
	{
		int dif = 127;
		while(true)
		{
			if(joy1Btn(6))
				dif=187;
			if(joy1Btn(8))
				dif=50;
			servo[servoRearGrabberR] = dif - 15;
			servo[servoRearGrabberL] = 255 - dif;
			wait1Msec(50);
		}
	}
}

task raiseLift()
{
	nMotorEncoder[motorRightPulley] = 0;
	bool stabilization = true;
	while(true)
	{
		getJoystickSettings(joystick);
		int liftStick = joystick.joy2_y1;
		nxtDisplayCenteredBigTextLine(2,"%d",liftStick);
		if(abs(liftStick) >= 10)
		{
			motor[motorLeftPulley] = liftStick;
			motor[motorRightPulley] = liftStick;
		}
		else
		{
			if(stabilization)
			{
				motor[motorRightPulley] = 0;
				motor[motorLeftPulley] = 0;
				wait1Msec(100);
				int stabilizingVal = abs(nMotorEncoder[motorRightPulley]);
				clearTimer(T4);
				while(abs(liftStick) <= 10 && time1(T4) < 5000)
				{
					liftStick = joystick.joy2_y1;
					int change = stabilizingVal - abs(nMotorEncoder[motorRightPulley]);
					if(change > 100)
					{
						motor[motorRightPulley] = 30;
						motor[motorLeftPulley] = 30;
					}
					/*else if(change < -100)
					{
						motor[motorRightPulley] = -30;
						motor[motorLeftPulley] = -30;
					}*/
					else
					{
						motor[motorRightPulley] = 0;
						motor[motorLeftPulley] = 0;
					}
				}
				while(abs(liftStick) <= 10)
				{
					liftStick = joystick.joy2_y1;
					motor[motorRightPulley] = 0;
					motor[motorLeftPulley] = 0;
				}
			}
			motor[motorRightPulley] = 0;
			motor[motorLeftPulley] = 0;
		}
	}
	while(true){wait1Msec(50);}
}

task HoloDrive()
{
	getJoystickSettings(joystick);
	startTask(moveLift); //Starts the task for moving the lift servos
	startTask(moveGrabber); //Start the task for moving the rear grabbers
	startTask(raiseLift); //Starts the task for moving the lift up and down
	while(true)
	{
		//Takes input from the joystick and sets variables to them
		getJoystickSettings(joystick);
		x1 = joystick.joy1_x1;
		y1 = joystick.joy1_y1;
		x2 = joystick.joy1_x2;
		y2 = joystick.joy1_y2;
		joy2y1 = joystick.joy2_y1;
		joy2y2 = joystick.joy2_y2;

		//Scales all the values to the 0-100 range of motor controllers
		x1 = x1 / 1.28;
		y1 = y1 / 1.28;
		x2 = x2 / 1.28;
		y2 = y2 / 1.28;
		joy2y1 = joy2y1 / 1.28;
		joy2y2 = joy2y2 / 1.28;

		//Formula for determining the wheel speeds based on the joystick position.
		FL = y1 + x1 + x2;
		BL = y1 - x1 + x2;
		FR = y1 - x1 - x2;
		BR = y1 + x1 - x2;

		normalize(); //Use normalize function to compensate for wheel values above 100 or below -100

		//Scaling motor values
		if(abs(x1) > 10 && abs(y1) > 10) //If the robot is strafing, run the wheels at full speed
		{
			FL = FL;
			BL = BL;
			FR = FR;
			BR = BR;
		}
		else if(joy1Btn(5)) //If the driver is pressing the speed up button, run at full speed
		{
			FL = FL;
			BL = BL;
			FR = FR;
			BR = BR;
		}
		else //Otherwise, run at 60% speed
		{
			FL = FL * 0.60;
			BL = BL * 0.60;
			FR = FR * 0.60;
			BR = BR * 0.60;
		}

		//Run the motors
		//This section checks
		if((abs(x2) >= 10) && (joy1Btn(3))) //Slow down button 1
		{
			motor[motorFL] = x2 / 5;
			motor[motorBL] = x2 / 5;
			motor[motorFR] = x2 / 5;
			motor[motorBR] = x2 / 5;
		}
		else if((abs(x2) >= 10) && (joy1Btn(2))) //Slower down button 2
		{
			motor[motorFL] = x2 / 3;
			motor[motorBL] = x2 / 3;
			motor[motorFR] = x2 / 3;
			motor[motorBR] = x2 / 3;
		}
		else if(abs(x2) >= 10) //Regular running speed
		{
			motor[motorFL] = x2;
			motor[motorBL] = x2;
			motor[motorFR] = x2;
			motor[motorBR] = x2;
		}
		else if((abs(x1) >= 10 || abs(y1) >= 10) && joy1Btn(2))
		{
			motor[motorFL] = FL / 2;
			motor[motorBL] = BL / 2;
			motor[motorFR] = -FR / 2;
			motor[motorBR] = -BR / 2;
		}
		else if((abs(x1) >= 10 || abs(y1) >= 10) && joy1Btn(3))
		{
			motor[motorFL] = FL / 3;
			motor[motorBL] = BL / 3;
			motor[motorFR] = -FR / 3;
			motor[motorBR] = -BR / 3;
		}
		else if(abs(x1) >= 10 || abs(y1) >= 10)
		{
			motor[motorFL] = FL;
			motor[motorBL] = BL;
			motor[motorFR] = -FR;
			motor[motorBR] = -BR;
		}
		else
		{
			motor[motorFL] = 0;
			motor[motorBL] = 0;
			motor[motorFR] = 0;
			motor[motorBR] = 0;
		}
		//Spins manipulator
		if(joy1Btn(5))
			motor[motorManipulator] = -70;
		else if(joy1Btn(7))
			motor[motorManipulator] = 70;
		else
			motor[motorManipulator] = 0;
		wait1Msec(5);
	}
}

task main()
{
	initializeRobot();
	waitForStart();
	getJoystickSettings(joystick);
	//startTask(moveGrabber);
	//startTask(raiseLift);
	startTask(HoloDrive);
	while(true){wait1Msec(5);}
} // End of task main
